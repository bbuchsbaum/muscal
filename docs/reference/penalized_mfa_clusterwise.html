<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Penalized MFA with Clusterwise Spatial Smoothness Constraints — penalized_mfa_clusterwise • muscal</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Penalized MFA with Clusterwise Spatial Smoothness Constraints — penalized_mfa_clusterwise"><meta property="og:description" content="This function implements a spatially-regularized Multiple Factor Analysis for
multi-subject neuroimaging or spatial cluster data. Unlike standard MFA which
encourages similarity among block loadings globally, this method uses spatial
coordinates of clusters (e.g., brain regions, spatial locations) to construct
a graph and enforces smoothness of loadings among spatially adjacent clusters
via a graph Laplacian penalty."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">


    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">muscal</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/linked_mfa.html">Linked Multiple Factor Analysis</a>
    </li>
    <li>
      <a href="../articles/mfa.html">Multiple Factor Analysis</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"></ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Penalized MFA with Clusterwise Spatial Smoothness Constraints</h1>

    <div class="hidden name"><code>penalized_mfa_clusterwise.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function implements a spatially-regularized Multiple Factor Analysis for
multi-subject neuroimaging or spatial cluster data. Unlike standard MFA which
encourages similarity among block loadings globally, this method uses spatial
coordinates of clusters (e.g., brain regions, spatial locations) to construct
a graph and enforces smoothness of loadings among spatially adjacent clusters
via a graph Laplacian penalty.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">penalized_mfa_clusterwise</span><span class="op">(</span></span>
<span>  <span class="va">data_list</span>,</span>
<span>  <span class="va">coords_list</span>,</span>
<span>  ncomp <span class="op">=</span> <span class="fl">2L</span>,</span>
<span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  adjacency_opts <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">10L</span>,</span>
<span>  nsteps_inner <span class="op">=</span> <span class="fl">1L</span>,</span>
<span>  learning_rate <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span>  optimizer <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"gradient"</span>, <span class="st">"adam"</span><span class="op">)</span>,</span>
<span>  beta1 <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  beta2 <span class="op">=</span> <span class="fl">0.999</span>,</span>
<span>  adam_epsilon <span class="op">=</span> <span class="fl">1e-08</span>,</span>
<span>  tol_obj <span class="op">=</span> <span class="fl">1e-07</span>,</span>
<span>  tol_inner <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  preproc <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  memory_budget_mb <span class="op">=</span> <span class="fl">1024</span>,</span>
<span>  normalized_laplacian <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">pmfa_cluster</span><span class="op">(</span></span>
<span>  <span class="va">data_list</span>,</span>
<span>  <span class="va">coords_list</span>,</span>
<span>  ncomp <span class="op">=</span> <span class="fl">2L</span>,</span>
<span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  adjacency_opts <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  max_iter <span class="op">=</span> <span class="fl">10L</span>,</span>
<span>  nsteps_inner <span class="op">=</span> <span class="fl">1L</span>,</span>
<span>  learning_rate <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span>  optimizer <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"gradient"</span>, <span class="st">"adam"</span><span class="op">)</span>,</span>
<span>  beta1 <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  beta2 <span class="op">=</span> <span class="fl">0.999</span>,</span>
<span>  adam_epsilon <span class="op">=</span> <span class="fl">1e-08</span>,</span>
<span>  tol_obj <span class="op">=</span> <span class="fl">1e-07</span>,</span>
<span>  tol_inner <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  preproc <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  memory_budget_mb <span class="op">=</span> <span class="fl">1024</span>,</span>
<span>  normalized_laplacian <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>


<dl><dt id="arg-data-list">data_list<a class="anchor" aria-label="anchor" href="#arg-data-list"></a></dt>
<dd><p>A list of length \(S\) containing numeric matrices. Each element
\(\mathbf{X}_s\) is an \(n_s \times k_s\) matrix where \(n_s\) is the number
of observations and \(k_s\) is the number of clusters/features for subject \(s\).
Data should be column-centered (mean zero per cluster) for proper reconstruction.</p></dd>


<dt id="arg-coords-list">coords_list<a class="anchor" aria-label="anchor" href="#arg-coords-list"></a></dt>
<dd><p>A list of length \(S\) containing coordinate matrices. Each element
is a \(k_s \times 3\) matrix of (x, y, z) spatial coordinates for the clusters in
the corresponding data block. Must have exactly 3 columns.</p></dd>


<dt id="arg-ncomp">ncomp<a class="anchor" aria-label="anchor" href="#arg-ncomp"></a></dt>
<dd><p>Integer number of latent components to extract per block (default: 2).
When a block has fewer than `ncomp` clusters, the effective rank is automatically
reduced to match the number of clusters.</p></dd>


<dt id="arg-lambda">lambda<a class="anchor" aria-label="anchor" href="#arg-lambda"></a></dt>
<dd><p>Non-negative scalar controlling the spatial smoothness penalty strength
(default: 1). Larger values enforce stronger smoothness among spatially adjacent
clusters. When \(\lambda = 0\), the method reduces to independent PCA per block.
Typical range: 0.1 to 10.</p></dd>


<dt id="arg-adjacency-opts">adjacency_opts<a class="anchor" aria-label="anchor" href="#arg-adjacency-opts"></a></dt>
<dd><p>A named list of options passed to the internal
`spatial_constraints` function for adjacency matrix construction (default: empty list).
Supported options:</p><ul><li><p><code>k_nn</code>: Number of nearest neighbors (default: 6)</p></li>
</ul></dd>


<dt id="arg-max-iter">max_iter<a class="anchor" aria-label="anchor" href="#arg-max-iter"></a></dt>
<dd><p>Maximum number of outer block-coordinate descent iterations (default: 10).
More iterations allow better convergence but increase computation time. Typical range:
10 to 100.</p></dd>


<dt id="arg-nsteps-inner">nsteps_inner<a class="anchor" aria-label="anchor" href="#arg-nsteps-inner"></a></dt>
<dd><p>Number of gradient update steps per block in each outer iteration
(default: 1). Higher values perform more thorough optimization of each block before
moving to the next. For stability, starting with 1 is recommended.</p></dd>


<dt id="arg-learning-rate">learning_rate<a class="anchor" aria-label="anchor" href="#arg-learning-rate"></a></dt>
<dd><p>Step size for the optimizer (default: 0.01). Controls the magnitude
of updates in the gradient direction. Too large may cause divergence; too small slows
convergence. Typical range: 0.001 to 0.1.</p></dd>


<dt id="arg-optimizer">optimizer<a class="anchor" aria-label="anchor" href="#arg-optimizer"></a></dt>
<dd><p>Character string specifying the optimization algorithm (default: "gradient").
Options are:</p><ul><li><p><code>"gradient"</code>: Standard gradient descent with fixed learning rate</p></li>
<li><p><code>"adam"</code>: Adaptive Moment Estimation with momentum and adaptive learning rates</p></li>
</ul><p>Adam is generally more robust but gradient descent offers more control.</p></dd>


<dt id="arg-beta-">beta1<a class="anchor" aria-label="anchor" href="#arg-beta-"></a></dt>
<dd><p>Adam hyperparameter for first moment decay (default: 0.9). Controls the
exponential decay rate for gradient moving average. Typical range: 0.8 to 0.95.
Only used when `optimizer = "adam"`.</p></dd>


<dt id="arg-beta-">beta2<a class="anchor" aria-label="anchor" href="#arg-beta-"></a></dt>
<dd><p>Adam hyperparameter for second moment decay (default: 0.999). Controls
the exponential decay rate for squared gradient moving average. Typical range:
0.99 to 0.9999. Only used when `optimizer = "adam"`.</p></dd>


<dt id="arg-adam-epsilon">adam_epsilon<a class="anchor" aria-label="anchor" href="#arg-adam-epsilon"></a></dt>
<dd><p>Small constant added to denominator in Adam for numerical stability
(default: 1e-8). Prevents division by zero. Only used when `optimizer = "adam"`.</p></dd>


<dt id="arg-tol-obj">tol_obj<a class="anchor" aria-label="anchor" href="#arg-tol-obj"></a></dt>
<dd><p>Numeric tolerance for outer loop convergence based on relative change
in objective function (default: 1e-7). The algorithm stops when
\(|f^{(t+1)} - f^{(t)}| / (|f^{(t)}| + \epsilon) &lt; \text{tol_obj}\).
Smaller values require more precise convergence. Typical range: 1e-8 to 1e-5.</p></dd>


<dt id="arg-tol-inner">tol_inner<a class="anchor" aria-label="anchor" href="#arg-tol-inner"></a></dt>
<dd><p>Optional numeric tolerance for inner loop convergence based on
Frobenius norm of change in loading matrix (default: NULL, no early stopping).
When specified, inner loop stops if \(\|\mathbf{V}_s^{\text{new}} - \mathbf{V}_s\|_F &lt; \text{tol_inner}\).</p></dd>


<dt id="arg-verbose">verbose<a class="anchor" aria-label="anchor" href="#arg-verbose"></a></dt>
<dd><p>Logical indicating whether to print iteration progress (default: FALSE).
When TRUE, displays detailed information about objective values, convergence, memory
usage, and potential issues using the `cli` package.</p></dd>


<dt id="arg-preproc">preproc<a class="anchor" aria-label="anchor" href="#arg-preproc"></a></dt>
<dd><p>Preprocessing specification (default: NULL, will force centering).
Can be:</p><ul><li><p><code>NULL</code>: Automatically applies centering to each block</p></li>
<li><p>A single `pre_processor` object: Applied independently to each block</p></li>
<li><p>A list of `pre_processor` objects: One per block</p></li>
</ul><p>**Critical:** Preprocessing must preserve the number of columns to maintain
spatial correspondence.</p></dd>


<dt id="arg-memory-budget-mb">memory_budget_mb<a class="anchor" aria-label="anchor" href="#arg-memory-budget-mb"></a></dt>
<dd><p>Numeric specifying the maximum memory in megabytes allocated
per block for precomputing \(\mathbf{X}_s^\top \mathbf{X}_s\) (default: 1024).
If a block's \(k_s^2 \times 8 / (1024^2)\) exceeds this budget, gradients are
computed on-the-fly instead. Increase for better speed with large memory; decrease
if memory is constrained.</p></dd>


<dt id="arg-normalized-laplacian">normalized_laplacian<a class="anchor" aria-label="anchor" href="#arg-normalized-laplacian"></a></dt>
<dd><p>Logical indicating whether to use the normalized graph
Laplacian (default: TRUE). When TRUE, uses \(\mathbf{L}_{\text{sym}} = \mathbf{D}^{-1/2} \mathbf{L} \mathbf{D}^{-1/2}\)
for scale-free smoothness that is independent of node degree. When FALSE, uses the
unnormalized Laplacian \(\mathbf{L} = \mathbf{D} - \mathbf{A}\). Normalized is
recommended for most applications.</p></dd>

</dl></div>
    <div id="value">
    <h2>Value</h2>
    <p>A `multiblock_projector` object of class `"penalized_mfa_clusterwise"` with
  the following components:</p><dl><dt><code>v</code></dt>
<dd><p>Concatenated loading matrix (total_clusters × ncomp) formed by
      vertically stacking all block-specific loading matrices. Padded with zeros for
      variable-rank blocks.</p></dd>

    <dt><code>preproc</code></dt>
<dd><p>A pass-through preprocessor (identity transformation), since
      this function expects pre-processed input.</p></dd>

    <dt><code>block_indices</code></dt>
<dd><p>Named list indicating which rows of `v` correspond to
      each block/subject. Each element is an integer vector of row indices.</p></dd>


</dl><p>Additional information stored as named elements (accessible via `$`):</p><dl><dt><code>V_list</code></dt>
<dd><p>List of length S containing the final orthonormal loading
      matrices for each block. Each element is a \(k_s \times r_s\) matrix where
      \(r_s = \min(\text{ncomp}, k_s)\).</p></dd>

    <dt><code>Sadj</code></dt>
<dd><p>The (normalized or unnormalized) graph Laplacian matrix used
      for the spatial smoothness penalty. Sparse matrix of dimension
      \(\sum_s k_s \times \sum_s k_s\).</p></dd>

    <dt><code>LV</code></dt>
<dd><p>The matrix product \(\mathbf{L} \mathbf{V}\) from the final
      iteration, useful for computing spatial penalty contributions.</p></dd>

    <dt><code>obj_values</code></dt>
<dd><p>Numeric vector of objective function values at each
      outer iteration, including the initial value. Length is (iterations_run + 1).</p></dd>

    <dt><code>lambda</code></dt>
<dd><p>The spatial smoothness penalty weight used.</p></dd>

    <dt><code>precompute_info</code></dt>
<dd><p>Logical vector of length S indicating which blocks
      used precomputed \(\mathbf{X}_s^\top \mathbf{X}_s\) (TRUE) vs. on-the-fly
      computation (FALSE).</p></dd>

    <dt><code>iterations_run</code></dt>
<dd><p>Integer indicating how many outer iterations were
      completed before convergence or reaching max_iter.</p></dd>

    <dt><code>ncomp_block</code></dt>
<dd><p>Integer vector of length S containing the effective
      number of components extracted for each block (may differ from `ncomp` for
      blocks with fewer clusters).</p></dd>


</dl></div>
    <div id="details">
    <h2>Details</h2>
    <p>## Optimization Problem</p>
<p>For \(S\) subjects/blocks with data matrices \(\mathbf{X}_s \in \mathbb{R}^{n_s \times k_s}\)
(where \(k_s\) is the number of clusters for subject \(s\)), we estimate
orthonormal loading matrices \(\mathbf{V}_s \in \mathbb{R}^{k_s \times r_s}\)
by minimizing:</p>
<p>$$
  \min_{\{\mathbf{V}_s\}} \sum_{s=1}^S \|\mathbf{X}_s - \mathbf{X}_s \mathbf{V}_s \mathbf{V}_s^\top\|_F^2
  + \lambda \,\text{tr}(\mathbf{V}^\top \mathbf{L} \mathbf{V})
$$</p>
<p>where:</p><ul><li><p>The first term is the reconstruction error (sum of squared residuals)</p></li>
<li><p>\(\mathbf{V}\) is the vertical concatenation of all \(\mathbf{V}_s\)</p></li>
<li><p>\(\mathbf{L} = \mathbf{D} - \mathbf{A}\) is the graph Laplacian</p></li>
<li><p>\(\mathbf{A}\) is the adjacency matrix constructed from spatial coordinates</p></li>
<li><p>\(\mathbf{D}\) is the degree matrix (\(D_{ii} = \sum_j A_{ij}\))</p></li>
<li><p>\(\lambda \geq 0\) controls the spatial smoothness strength</p></li>
</ul><p>## Spatial Smoothness Penalty</p>
<p>The Laplacian penalty \(\text{tr}(\mathbf{V}^\top \mathbf{L} \mathbf{V})\) can be
rewritten as:
$$
  \frac{1}{2} \sum_{i,j} A_{ij} \|\mathbf{v}_i - \mathbf{v}_j\|_2^2
$$</p>
<p>This penalizes the squared Euclidean distance between loadings of adjacent clusters.
When two clusters \(i\) and \(j\) are connected (\(A_{ij} = 1\)), their
loading vectors \(\mathbf{v}_i\) and \(\mathbf{v}_j\) are encouraged to be similar.</p>
<p>**Normalized vs. Unnormalized Laplacian:**</p><dl><dt><strong>Unnormalized</strong> (<code>normalized_laplacian = FALSE</code>)</dt>
<dd><p>\(\mathbf{L} = \mathbf{D} - \mathbf{A}\). Smoothness is scaled by node degree;
    high-degree nodes have stronger smoothness constraints.</p></dd>

  <dt><strong>Normalized</strong> (<code>normalized_laplacian = TRUE</code>, default)</dt>
<dd><p>\(\mathbf{L}_{\text{sym}} = \mathbf{D}^{-1/2} \mathbf{L} \mathbf{D}^{-1/2}\).
    Scale-free smoothness that is independent of node degree. Recommended for
    most applications.</p></dd>


</dl><p>## Graph Construction</p>
<p>The spatial adjacency graph is built using k-nearest neighbors (k-NN) in 3D space:</p><ol><li><p>Cluster coordinates from all subjects are pooled</p></li>
<li><p>For each cluster, find its k nearest neighbors (default: k=6)</p></li>
<li><p>Create edges between each cluster and its neighbors</p></li>
<li><p>Symmetrize the adjacency matrix</p></li>
</ol><p>The number of neighbors can be controlled via `adjacency_opts = list(k_nn = k)`.</p>
<p>## Optimization Algorithm</p>
<p>The method uses block-coordinate descent (BCD) with Riemannian optimization:</p>
<p>1. **Initialization**: Initialize each \(\mathbf{V}_s\) via SVD of \(\mathbf{X}_s\)
2. **Outer loop** (max_iter iterations): Cycle through all subjects/blocks
3. **Inner loop** (nsteps_inner steps per block):
   - Compute reconstruction gradient: \(\nabla_{\mathbf{V}_s} = -2 \mathbf{X}_s^\top \mathbf{X}_s \mathbf{V}_s\)
   - Compute spatial gradient: \(2\lambda \mathbf{L}_{ss} \mathbf{V}_s + 2\lambda \mathbf{L}_{s,-s} \mathbf{V}_{-s}\)
   - Project combined gradient onto Stiefel manifold tangent space
   - Update via gradient descent or Adam
   - Retract to manifold via QR decomposition
4. **Convergence check**: Stop when relative change in objective &lt; `tol_obj`</p>
<p>## Memory Management</p>
<p>For large datasets, computing and storing \(\mathbf{X}_s^\top \mathbf{X}_s\) for
all blocks may exceed available memory. The `memory_budget_mb` parameter controls
this tradeoff:</p>
<ul><li><p>**Precomputed mode** (if \(k_s^2 \times 8 / (1024^2)\) &lt; `memory_budget_mb`):
    Store \(\mathbf{X}_s^\top \mathbf{X}_s\) for faster gradient computation</p></li>
<li><p>**On-the-fly mode** (otherwise): Compute gradients as needed, saving memory
    at the cost of computation time</p></li>
</ul><p>## Variable-Rank Loadings</p>
<p>When subjects have different numbers of clusters, each block can have a different
effective rank. The algorithm automatically sets \(r_s = \min(\text{ncomp}, k_s)\)
for each block and pads the concatenated loading matrix with zeros for consistency.</p>
<p>## Preprocessing</p>
<p>Data preprocessing is crucial for reconstruction-based methods. The function
defaults to centering each block if no preprocessing is specified. **Important:**
Preprocessing must preserve the number of columns (clusters) to maintain
correspondence with spatial coordinates.</p>
<p>## When Lambda = 0</p>
<p>When \(\lambda = 0\), the spatial penalty is disabled and the method reduces
to independent PCA on each block. This provides a useful baseline for comparison.</p>
<p>## Practical Considerations</p>
<dl><dt><strong>Choosing lambda</strong></dt>
<dd><p>Start with \(\lambda = 0\) (no smoothness) and gradually increase.
    Typical range: 0.1 to 10. Monitor the objective function components
    (reconstruction vs. smoothness) to balance the tradeoff.</p></dd>

  <dt><strong>Number of neighbors</strong></dt>
<dd><p>More neighbors (larger k-NN) create a denser graph with stronger smoothness
    constraints. Default k=6 works well for 3D spatial data.</p></dd>

  <dt><strong>Convergence</strong></dt>
<dd><p>The method may converge slowly for large \(\lambda\). Increase `max_iter`
    or adjust `learning_rate` if needed.</p></dd>

  <dt><strong>Optimizer choice</strong></dt>
<dd><p>Adam is generally more robust and converges faster. Use gradient descent
    for better control or when Adam's adaptive behavior is undesired.</p></dd>


</dl></div>
    <div id="engineering-improvements">
    <h2>Engineering Improvements</h2>


<p>This implementation includes several optimizations:</p><ul><li><p>**Mathematical**: Normalized Laplacian default, \(\lambda=0\) optimization skips</p></li>
<li><p>**Numerical**: Sparse matrix operations, in-block QR retraction, fast orthogonalization</p></li>
<li><p>**Stability**: Variable-rank loadings, robust parameter validation, Adam state management</p></li>
<li><p>**Architecture**: Modular helper functions, comprehensive logging, clear error messages</p></li>
<li><p>**Memory**: Adaptive memory budget, efficient gradient computation strategies</p></li>
<li><p>**API**: Shorter `pmfa_cluster()` alias, consistent naming conventions</p></li>
</ul></div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span> <span class="co"># \dontrun{</span></span></span>
<span class="r-in"><span><span class="co"># Example 1: Basic usage with simulated spatial cluster data</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">S</span> <span class="op">&lt;-</span> <span class="fl">3</span>  <span class="co"># 3 subjects</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Generate data with spatial structure</span></span></span>
<span class="r-in"><span><span class="va">data_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">S</span>, <span class="kw">function</span><span class="op">(</span><span class="va">s</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span>  <span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">50</span>  <span class="co"># 50 observations</span></span></span>
<span class="r-in"><span>  <span class="va">k</span> <span class="op">&lt;-</span> <span class="fl">20</span>  <span class="co"># 20 clusters</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span> <span class="op">*</span> <span class="va">k</span><span class="op">)</span>, <span class="va">n</span>, <span class="va">k</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Generate 3D spatial coordinates for clusters</span></span></span>
<span class="r-in"><span><span class="va">coords_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">S</span>, <span class="kw">function</span><span class="op">(</span><span class="va">s</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">20</span> <span class="op">*</span> <span class="fl">3</span>, <span class="fl">0</span>, <span class="fl">10</span><span class="op">)</span>, <span class="fl">20</span>, <span class="fl">3</span><span class="op">)</span>  <span class="co"># Random 3D positions</span></span></span>
<span class="r-in"><span><span class="op">}</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Fit model with spatial smoothness</span></span></span>
<span class="r-in"><span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu">penalized_mfa_clusterwise</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data_list</span>, <span class="va">coords_list</span>,</span></span>
<span class="r-in"><span>  ncomp <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  max_iter <span class="op">=</span> <span class="fl">20</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Plot convergence</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">res</span><span class="op">$</span><span class="va">obj_values</span>, type <span class="op">=</span> <span class="st">'b'</span>, xlab <span class="op">=</span> <span class="st">'Iteration'</span>, ylab <span class="op">=</span> <span class="st">'Objective'</span>,</span></span>
<span class="r-in"><span>     main <span class="op">=</span> <span class="st">'Convergence of Spatially-Regularized MFA'</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 2: Using the shorter alias</span></span></span>
<span class="r-in"><span><span class="va">res2</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span><span class="va">data_list</span>, <span class="va">coords_list</span>, ncomp <span class="op">=</span> <span class="fl">2</span>, lambda <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 3: Compare different lambda values</span></span></span>
<span class="r-in"><span><span class="va">lambdas</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">5</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">results</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">lambdas</span>, <span class="kw">function</span><span class="op">(</span><span class="va">lam</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span>  <span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span><span class="va">data_list</span>, <span class="va">coords_list</span>, ncomp <span class="op">=</span> <span class="fl">2</span>, lambda <span class="op">=</span> <span class="va">lam</span>,</span></span>
<span class="r-in"><span>                      verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>    lambda <span class="op">=</span> <span class="va">lam</span>,</span></span>
<span class="r-in"><span>    final_obj <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">tail</a></span><span class="op">(</span><span class="va">fit</span><span class="op">$</span><span class="va">obj_values</span>, <span class="fl">1</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>    iterations <span class="op">=</span> <span class="va">fit</span><span class="op">$</span><span class="va">iterations_run</span></span></span>
<span class="r-in"><span>  <span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 4: Using Adam optimizer for faster convergence</span></span></span>
<span class="r-in"><span><span class="va">res_adam</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data_list</span>, <span class="va">coords_list</span>,</span></span>
<span class="r-in"><span>  ncomp <span class="op">=</span> <span class="fl">3</span>,</span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  optimizer <span class="op">=</span> <span class="st">"adam"</span>,</span></span>
<span class="r-in"><span>  learning_rate <span class="op">=</span> <span class="fl">0.05</span>,</span></span>
<span class="r-in"><span>  max_iter <span class="op">=</span> <span class="fl">30</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 5: Controlling k-NN graph construction</span></span></span>
<span class="r-in"><span><span class="va">res_dense</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data_list</span>, <span class="va">coords_list</span>,</span></span>
<span class="r-in"><span>  ncomp <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  adjacency_opts <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>k_nn <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>,  <span class="co"># More neighbors = denser graph</span></span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 6: Using unnormalized Laplacian</span></span></span>
<span class="r-in"><span><span class="va">res_unnorm</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data_list</span>, <span class="va">coords_list</span>,</span></span>
<span class="r-in"><span>  ncomp <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  normalized_laplacian <span class="op">=</span> <span class="cn">FALSE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 7: Memory-constrained settings</span></span></span>
<span class="r-in"><span><span class="co"># For large datasets, reduce memory budget</span></span></span>
<span class="r-in"><span><span class="va">res_mem</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data_list</span>, <span class="va">coords_list</span>,</span></span>
<span class="r-in"><span>  ncomp <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  memory_budget_mb <span class="op">=</span> <span class="fl">256</span>,  <span class="co"># Limit memory per block</span></span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Check which blocks used precomputed gradients</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">res_mem</span><span class="op">$</span><span class="va">precompute_info</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 8: Extracting block-specific loadings</span></span></span>
<span class="r-in"><span><span class="va">V_list</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">V_list</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Loadings for first subject</span></span></span>
<span class="r-in"><span><span class="va">V1</span> <span class="op">&lt;-</span> <span class="va">V_list</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">V1</span><span class="op">)</span>  <span class="co"># k_s x ncomp</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Visualize spatial smoothness of first loading vector</span></span></span>
<span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">scatterplot3d</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/pkg/scatterplot3d/man/scatterplot3d.html" class="external-link">scatterplot3d</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">coords_list</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,</span></span>
<span class="r-in"><span>  color <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rank.html" class="external-link">rank</a></span><span class="op">(</span><span class="va">V1</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  main <span class="op">=</span> <span class="st">"Spatial Pattern of First Loading (Subject 1)"</span>,</span></span>
<span class="r-in"><span>  xlab <span class="op">=</span> <span class="st">"X"</span>, ylab <span class="op">=</span> <span class="st">"Y"</span>, zlab <span class="op">=</span> <span class="st">"Z"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 9: Examining the spatial penalty contribution</span></span></span>
<span class="r-in"><span><span class="co"># Extract Laplacian and loadings</span></span></span>
<span class="r-in"><span><span class="va">L</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">Sadj</span></span></span>
<span class="r-in"><span><span class="va">LV</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">LV</span></span></span>
<span class="r-in"><span><span class="va">v</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">v</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Compute spatial penalty: tr(V' L V)</span></span></span>
<span class="r-in"><span><span class="va">spatial_penalty</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">LV</span> <span class="op">*</span> <span class="va">v</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"Spatial penalty term:"</span>, <span class="va">spatial_penalty</span>, <span class="st">"\n"</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 10: Variable-rank loadings (blocks with different sizes)</span></span></span>
<span class="r-in"><span><span class="co"># Simulate data with varying cluster numbers</span></span></span>
<span class="r-in"><span><span class="va">data_var</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">50</span> <span class="op">*</span> <span class="fl">15</span><span class="op">)</span>, <span class="fl">50</span>, <span class="fl">15</span><span class="op">)</span>,  <span class="co"># 15 clusters</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">50</span> <span class="op">*</span> <span class="fl">20</span><span class="op">)</span>, <span class="fl">50</span>, <span class="fl">20</span><span class="op">)</span>,  <span class="co"># 20 clusters</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">50</span> <span class="op">*</span> <span class="fl">10</span><span class="op">)</span>, <span class="fl">50</span>, <span class="fl">10</span><span class="op">)</span>   <span class="co"># 10 clusters</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">coords_var</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">15</span> <span class="op">*</span> <span class="fl">3</span><span class="op">)</span>, <span class="fl">15</span>, <span class="fl">3</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">20</span> <span class="op">*</span> <span class="fl">3</span><span class="op">)</span>, <span class="fl">20</span>, <span class="fl">3</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span> <span class="op">*</span> <span class="fl">3</span><span class="op">)</span>, <span class="fl">10</span>, <span class="fl">3</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">res_var</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data_var</span>, <span class="va">coords_var</span>,</span></span>
<span class="r-in"><span>  ncomp <span class="op">=</span> <span class="fl">8</span>,  <span class="co"># Will be capped at 10 (smallest block)</span></span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># Check effective ranks per block</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">res_var</span><span class="op">$</span><span class="va">ncomp_block</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 11: Custom preprocessing per block</span></span></span>
<span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://bbuchsbaum.github.io/multivarious/" class="external-link">multivarious</a></span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">preproc_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://bbuchsbaum.github.io/multivarious/reference/center.html" class="external-link">center</a></span><span class="op">(</span><span class="op">)</span>,        <span class="co"># Just center first block</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://bbuchsbaum.github.io/multivarious/reference/standardize.html" class="external-link">standardize</a></span><span class="op">(</span><span class="op">)</span>,   <span class="co"># Center and scale second block</span></span></span>
<span class="r-in"><span>  <span class="fu"><a href="https://bbuchsbaum.github.io/multivarious/reference/center.html" class="external-link">center</a></span><span class="op">(</span><span class="op">)</span>         <span class="co"># Just center third block</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">res_preproc</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span></span></span>
<span class="r-in"><span>  <span class="va">data_list</span>, <span class="va">coords_list</span>,</span></span>
<span class="r-in"><span>  ncomp <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="fl">1</span>,</span></span>
<span class="r-in"><span>  preproc <span class="op">=</span> <span class="va">preproc_list</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Example 12: Lambda selection via cross-validation style approach</span></span></span>
<span class="r-in"><span><span class="co"># (Simplified - would need proper CV in practice)</span></span></span>
<span class="r-in"><span><span class="va">lambda_grid</span> <span class="op">&lt;-</span> <span class="fl">10</span><span class="op">^</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="va">cv_results</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span></span>
<span class="r-in"><span>  lambda <span class="op">=</span> <span class="va">lambda_grid</span>,</span></span>
<span class="r-in"><span>  recon_error <span class="op">=</span> <span class="cn">NA</span>,</span></span>
<span class="r-in"><span>  spatial_penalty <span class="op">=</span> <span class="cn">NA</span>,</span></span>
<span class="r-in"><span>  total_obj <span class="op">=</span> <span class="cn">NA</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">lambda_grid</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span></span>
<span class="r-in"><span>  <span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu">pmfa_cluster</span><span class="op">(</span><span class="va">data_list</span>, <span class="va">coords_list</span>, ncomp <span class="op">=</span> <span class="fl">2</span>,</span></span>
<span class="r-in"><span>                      lambda <span class="op">=</span> <span class="va">lambda_grid</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="va">cv_results</span><span class="op">$</span><span class="va">total_obj</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">tail</a></span><span class="op">(</span><span class="va">fit</span><span class="op">$</span><span class="va">obj_values</span>, <span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-in"><span>  <span class="co"># Could decompose into reconstruction and spatial components</span></span></span>
<span class="r-in"><span><span class="op">}</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Plot objective vs lambda</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">cv_results</span><span class="op">$</span><span class="va">lambda</span>, <span class="va">cv_results</span><span class="op">$</span><span class="va">total_obj</span>, log <span class="op">=</span> <span class="st">"x"</span>,</span></span>
<span class="r-in"><span>     type <span class="op">=</span> <span class="st">"b"</span>, xlab <span class="op">=</span> <span class="st">"Lambda (log scale)"</span>, ylab <span class="op">=</span> <span class="st">"Final Objective"</span>,</span></span>
<span class="r-in"><span>     main <span class="op">=</span> <span class="st">"Objective Function vs. Smoothness Penalty"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span> <span class="co"># }</span></span></span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by Bradley Buchsbaum.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

      </footer></div>






  </body></html>

