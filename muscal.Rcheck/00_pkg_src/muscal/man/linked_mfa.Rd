% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/linked_mfa.R
\name{linked_mfa}
\alias{linked_mfa}
\title{Linked Multiple Factor Analysis (Linked MFA)}
\usage{
linked_mfa(
  Y,
  X,
  row_index,
  preproc = multivarious::center(),
  ncomp = 2,
  normalization = c("MFA", "None", "custom"),
  alpha = NULL,
  feature_groups = NULL,
  feature_lambda = 0,
  max_iter = 50,
  tol = 1e-06,
  ridge = 1e-08,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{Y}{Numeric matrix/data.frame (\code{N x q}) serving as the reference block.}

\item{X}{A list of numeric matrices/data.frames. Each element \code{X[[k]]} is \code{n_k x p_k}.}

\item{row_index}{A list of integer vectors. \code{row_index[[k]]} has length \code{n_k}
and maps rows of \code{X[[k]]} to rows of \code{Y} (values in \code{1..N}).}

\item{preproc}{A \code{multivarious} preprocessing pipeline (a \code{pre_processor}/\code{prepper})
or a list of them. If a list, it must have length \code{1 + length(X)} and will be
applied to \code{c(list(Y), X)} in that order.}

\item{ncomp}{Integer number of components to extract.}

\item{normalization}{Block weighting scheme. \code{"MFA"} uses inverse squared first
singular value per block; \code{"None"} uses uniform weights; \code{"custom"} uses \code{alpha}.}

\item{alpha}{Optional numeric vector of per-block weights (length \code{1 + length(X)}),
used when \code{normalization = "custom"}. The first weight corresponds to \code{Y}.}

\item{feature_groups}{Feature prior specification. One of:
\itemize{
\item \code{NULL} (no feature prior),
\item \code{"colnames"} to group X-features with identical column names across blocks,
\item a \code{data.frame} with columns \code{block}, \code{feature}, \code{group} and optional \code{weight}.
}}

\item{feature_lambda}{Non-negative scalar controlling strength of the feature prior.}

\item{max_iter}{Maximum number of alternating least-squares iterations.}

\item{tol}{Relative tolerance on the objective for convergence.}

\item{ridge}{Non-negative ridge stabilization added to normal equations.}

\item{verbose}{Logical; if \code{TRUE}, prints iteration progress.}

\item{...}{Unused (reserved for future extensions).}
}
\value{
An object inheriting from \code{multivarious::multiblock_biprojector} with
additional class \code{"linked_mfa"}.
}
\description{
Linked MFA generalizes Multiple Factor Analysis (MFA) to the case where a single
reference block \code{Y} (with \code{N} rows) is linked to multiple blocks \code{X_k} that may
have different numbers of rows. Each row of \code{X_k} is mapped to a row of \code{Y} via
an index vector \code{row_index[[k]]}.
}
\details{
\strong{Model}
\deqn{Y \approx S B^\top}
\deqn{X_k \approx S[\mathrm{idx}_k,] V_k^\top}
where \code{S} is \code{N x ncomp}, \code{B} is \code{q x ncomp}, and each \code{V_k} is \code{p_k x ncomp}.

\strong{Feature similarity prior (v1)}
When \code{feature_lambda > 0} and \code{feature_groups} is supplied, Linked MFA applies
a group-shrinkage penalty that pulls the loading vectors of features in the same
group toward a shared group center.
}
\examples{
\donttest{
set.seed(1)
N <- 30
Y <- matrix(rnorm(N * 5), N, 5)
X1 <- matrix(rnorm(20 * 10), 20, 10)
X2 <- matrix(rnorm(15 * 8), 15, 8)
idx1 <- sample.int(N, nrow(X1), replace = FALSE)
idx2 <- sample.int(N, nrow(X2), replace = FALSE)

fit <- linked_mfa(Y, list(X1 = X1, X2 = X2), list(X1 = idx1, X2 = idx2), ncomp = 2)
stopifnot(nrow(multivarious::scores(fit)) == N)
}
}
