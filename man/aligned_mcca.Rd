% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aligned_mcca.R
\name{aligned_mcca}
\alias{aligned_mcca}
\title{Aligned Multiblock Canonical Correlation Analysis (Aligned MCCA)}
\usage{
aligned_mcca(
  X,
  row_index,
  N = NULL,
  preproc = multivarious::center(),
  ncomp = 2,
  ridge = 1e-06,
  block_weights = NULL,
  use_future = FALSE,
  ...
)
}
\arguments{
\item{X}{A list of numeric matrices/data.frames. Each element `X[[k]]` is
`n_k × p_k`.}

\item{row_index}{A list of integer vectors. `row_index[[k]]` has length `n_k`
and maps rows of `X[[k]]` to shared rows in `1..N`. Repeated indices are allowed.}

\item{N}{Optional integer specifying the number of shared rows. If `NULL`
(default), `N` is inferred as `max(unlist(row_index))`.}

\item{preproc}{A `multivarious` preprocessing pipeline (a `pre_processor`/`prepper`)
or a list of them. If a list, it must have length `length(X)` and will be
applied to `X` in that order.}

\item{ncomp}{Integer; number of canonical components to compute.}

\item{ridge}{Non-negative numeric scalar (or vector of length equal to the
number of blocks) controlling ridge stabilization. The effective ridge used
per block is scaled by the block's overall energy so the default works
across variable scalings.}

\item{block_weights}{Optional numeric vector of non-negative weights (length
= number of blocks) controlling each block's influence on the compromise.}

\item{use_future}{Logical; if `TRUE`, block-wise computations are performed via
`furrr::future_map()` when available.}

\item{...}{Unused (reserved for future extensions).}
}
\value{
An object inheriting from `multivarious::multiblock_biprojector` with
  additional class `"aligned_mcca"`. The object contains reference-space scores
  in `s` (`N × ncomp`) and block-wise canonical weights in `canonical_weights`.
  Per-block row-level score estimates are available in `partial_scores`.
}
\description{
Aligned MCCA extends MAXVAR generalized CCA (GCCA) to the setting where each
block has its own row set, linked to a common set of latent reference rows via
an integer index vector. No block is privileged: the shared scores live in the
reference row space `1..N`, and each block contributes through its row mapping.

This is the correlation-based counterpart to [aligned_mfa()], analogous to how
[mcca()] relates to [mfa()] when all blocks share rows.
}
\details{
## Model (MAXVAR GCCA with row alignment)
Let `S` be the shared score matrix for the `N` reference rows. For each block
`X_k` with `n_k` rows, `row_index[[k]]` maps its rows to reference rows:
\deqn{X_k \; \mathrm{linked\ to}\; S[\mathrm{idx}_k, ]}

Aligned MCCA computes `S` as the leading eigenvectors of a weighted sum of
block-wise ridge projection operators mapped into the reference space.

## High-dimensional stability
The implementation works in observation space and uses ridge-stabilized solves
on `n_k × n_k` systems, which remains well-posed when blocks have more variables
than rows (`p_k >> n_k`) or are rank deficient after preprocessing.
}
\examples{
\donttest{
set.seed(1)
N <- 30
X1 <- matrix(rnorm(20 * 10), 20, 10)
X2 <- matrix(rnorm(15 * 8), 15, 8)
idx1 <- sample.int(N, nrow(X1), replace = TRUE)
idx2 <- sample.int(N, nrow(X2), replace = TRUE)

fit <- aligned_mcca(list(X1 = X1, X2 = X2), list(X1 = idx1, X2 = idx2), N = N, ncomp = 2)
stopifnot(nrow(multivarious::scores(fit)) == N)
}
}
