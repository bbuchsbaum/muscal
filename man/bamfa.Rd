% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bamfa.R
\name{bamfa}
\alias{bamfa}
\alias{bamfa.default}
\alias{bamfa.list}
\alias{bamfa.multiblock}
\alias{bamfa.multidesign}
\title{Barycentric Multiple Factor Analysis (BaMFA)}
\usage{
bamfa(
  data,
  k_g = 2,
  k_l = 2,
  niter = 10,
  preproc = multivarious::center(),
  lambda_l = 0,
  tol = 1e-05,
  subject = NULL,
  ...
)

\method{bamfa}{default}(
  data,
  k_g = 2,
  k_l = 2,
  niter = 10,
  preproc = multivarious::center(),
  lambda_l = 0,
  tol = 1e-05,
  ...
)

\method{bamfa}{list}(
  data,
  k_g = 2,
  k_l = 2,
  niter = 10,
  preproc = multivarious::center(),
  lambda_l = 0,
  tol = 1e-05,
  ...
)

\method{bamfa}{multiblock}(
  data,
  k_g = 2,
  k_l = 2,
  niter = 10,
  preproc = multivarious::center(),
  lambda_l = 0,
  tol = 1e-05,
  ...
)

\method{bamfa}{multidesign}(
  data,
  k_g = 2,
  k_l = 2,
  niter = 10,
  preproc = multivarious::center(),
  lambda_l = 0,
  tol = 1e-05,
  subject,
  ...
)
}
\arguments{
\item{data}{A \code{list} of matrices (each a block, e.g., subject), a \code{multiblock} object,
or a \code{multidesign} object. If a list or multiblock, all blocks must have the same
number of rows (observations, e.g., conditions). If a multidesign, the \code{subject} parameter
must be specified to indicate how to split the data.}

\item{k_g}{Integer: Number of global components to extract (shared across blocks).}

\item{k_l}{Integer: Number of local components to extract (specific to each block).}

\item{niter}{Integer: Maximum number of iterations (default: 10).}

\item{preproc}{A preprocessing pipeline object from \code{multivarious} (default: \code{multivarious::center()}).}

\item{lambda_l}{Numeric: Non-negative ridge penalty applied when estimating the local scores \code{U_i}
using the internal \code{ls_ridge} function. Default: 0 (no penalty).}

\item{tol}{Numeric: Convergence tolerance. Stops if the relative change in the objective function
(Mean Squared Error) and/or the global loadings \code{G} is less than \code{tol}. Default: 1e-5.}

\item{subject}{Optional: A variable name identifying the blocking/subject variable when using a
multidesign object. Required only for the multidesign method.}

\item{...}{Additional arguments (currently unused).}
}
\value{
A \code{multiblock_projector} object with class \code{"bamfa"}.
The base projector stores the global loading matrix in \code{v}, the
concatenated preprocessor in \code{preproc}, and block mappings in
\code{block_indices}. Additional named elements passed via \code{...} include:
\itemize{
\item \code{B_list} -- block-specific local loading matrices.
\item \code{S_list} -- block-specific global score matrices.
\item \code{U_list} -- block-specific local score matrices.
\item \code{k_g} -- number of global components in the final model.
\item \code{k_l} -- requested number of local components.
\item \code{lambda_l} -- regularization parameter used for local scores \code{U_i}.
\item \code{niter_actual} -- actual number of iterations performed.
\item \code{objective_trace} -- objective function value at each iteration.
\item \code{g_change_trace} -- relative change in global loadings at each iteration.
\item \code{data_names} -- names of the input blocks/subjects.
\item \code{proclist_fitted} -- list of fitted preprocessors for each block.
}
}
\description{
Performs Barycentric Multiple Factor Analysis (BaMFA) using an alternating
optimization approach based on a two-level factor model.
It decomposes multi-block data (e.g., multiple subjects) into a shared global
subspace (\code{G}) and block-specific subspaces (\code{B_i}).
}
\details{
The algorithm models each data block \\(X_i\\) as:
\\[ X_i = S_i G^T + U_i B_i^T + E_i \\]
where \\(G\\) represents shared global loadings, \\(B_i\\) represents block-specific
local loadings, \\(S_i\\) and \\(U_i\\) are the corresponding scores, and \\(E_i\\) is noise.
Loadings are constrained to be orthonormal (\\(G^T G = I, B_i^T B_i = I\\)).

The algorithm aims to minimize the total reconstruction error:
\\[ \\sum_{i=1}^{m} ||X_i - S_i G^T - U_i B_i^T ||_F^2 \\]
using an iterative alternating optimization strategy (similar to Expectation-Maximization):
\enumerate{
\item \strong{Preprocessing:} Each block is preprocessed using the provided \code{preproc} pipeline.
\item \strong{Initialization:} Initialize global loadings \code{G} (via SVD on the mean block).
\item \strong{Iterate (E-step like):} For each block \code{i}, holding \code{G} fixed, update scores \code{S_i} (global projection), calculate residuals, find the local basis \code{B_i} from residuals (via SVD), and estimate local scores \code{U_i} (via projection, potentially regularized by \code{lambda_l}).
\item \strong{Iterate (M-step like):} Holding scores \code{S_i} fixed, update the global loadings \code{G} by performing SVD on an aggregated cross-product matrix \verb{sum(X_i^T S_i)}.
\item \strong{Repeat steps 3-4} for \code{niter} iterations or until convergence based on \code{tol}.
}
}
\section{Caveats and Limitations}{

\itemize{
\item \strong{Model Choice:} Assumes a linear factor model with orthogonal global and local components.
\item \strong{Initialization:} Results can be sensitive to the initialization of \code{G}.
\item \strong{Local Minima:} The alternating optimization algorithm may converge to a local minimum.
\item \strong{Interpretation:} The separation into global and local components depends on the model fit and ranks (\code{k_g}, \code{k_l}).
\item \strong{Regularization (\code{lambda_l}):} Penalizes the squared Frobenius norm of the local scores \code{U_i} via ridge regression.
\item \strong{Inference:} The method does not provide p-values or confidence intervals.
}
}

\examples{
# Generate example multi-block data (e.g., 3 subjects, 10 conditions, 50 features)
set.seed(123)
n_obs <- 10
n_features <- 50
n_subjects <- 3
data_list <- lapply(1:n_subjects, function(i) {
  matrix(rnorm(n_obs * n_features), n_obs, n_features) +
  matrix(rnorm(n_obs * 1, mean=i), n_obs, n_features) # Add subject offset
})
names(data_list) <- paste0("Subject_", 1:n_subjects)

# Run BaMFA with k_g=3 global, k_l=2 local components
result <- bamfa(data_list, k_g = 3, k_l = 2, niter = 10)
print(result)

}
\seealso{
\code{\link[multivarious]{pca}}, \code{\link[multidesign]{multiblock}}
}
