% Generated by hand for alpha tuner utility
\name{ipca_tune_alpha}
\alias{ipca_tune_alpha}
\title{Tune Tied Penalties for iPCA via 1D Alpha Search}
\usage{
ipca_tune_alpha(
  data,
  preproc = multivarious::center(),
  ncomp = 2,
  alpha_grid = 10^seq(-3, 3, by = 1),
  tie = c("inv_p", "inv_pbar", "equal"),
  holdout_frac = 0.05,
  n_masks = 1,
  warm_start = TRUE,
  method = c("auto", "gram", "dense"),
  max_iter = 100,
  tol = 1e-06,
  normalize_trace = TRUE,
  use_future = FALSE,
  eig_solver = c("auto", "full", "truncated"),
  eig_rank = NULL,
  eig_trunc_min_n = 400,
  seed = 1,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{data}{A list of matrices/data.frames or a \code{multiblock} object. Blocks must share rows.}

\item{preproc}{A \code{multivarious} preprocessing pipeline.}

\item{ncomp}{Integer; number of joint components to evaluate.}

\item{alpha_grid}{Positive numeric vector of candidate alpha values.}

\item{tie}{Penalty tying rule: \code{"inv_p"} (\code{alpha / p_k}), \code{"inv_pbar"}
(\code{alpha * mean(p) / p_k}), or \code{"equal"} (\code{alpha} for all blocks).}

\item{holdout_frac}{Fraction of entries to hold out in each block.}

\item{n_masks}{Number of independent random holdout masks. Holdout MSE is averaged
across masks for each alpha candidate.}

\item{warm_start}{Logical; if \code{TRUE}, alpha candidates are fit in ascending
order and each fit initializes from the previous alpha result within each mask.}

\item{method}{One of \code{"auto"}, \code{"gram"}, or \code{"dense"} for iPCA fits.}

\item{max_iter}{Maximum number of iPCA iterations per alpha.}

\item{tol}{Convergence tolerance for iPCA fits.}

\item{normalize_trace}{Logical; passed to \code{\link{ipca}}.}

\item{use_future}{Logical; passed to \code{\link{ipca}}.}

\item{eig_solver}{Eigensolver policy passed to \code{\link{ipca}}.}

\item{eig_rank}{Optional truncated eigensolver rank passed to \code{\link{ipca}}.}

\item{eig_trunc_min_n}{Minimum \code{n} where \code{eig_solver = "auto"} may switch
to truncated eigendecomposition in dense mode.}

\item{seed}{Integer random seed for holdout mask generation.}

\item{verbose}{Logical; print per-alpha progress.}

\item{...}{Additional arguments passed to \code{\link{ipca}}.}
}
\value{
A list with:
\describe{
  \item{best_alpha}{Selected alpha value.}
  \item{best_lambda}{Selected lambda vector of length K.}
  \item{results}{Data frame of alpha candidates and held-out MSE.}
  \item{fit}{iPCA fit refit on full data with \code{best_alpha}.}
}
}
\description{
Performs a lightweight 1D search over \code{alpha} and ties block penalties as
\code{lambda_k = alpha / p_k} (or related schemes), then selects the value with
the lowest held-out entry reconstruction MSE.
}
\details{
\strong{Tuning guidance}
\itemize{
  \item \code{tie = "inv_p"} is a good default for heterogeneous block widths.
  \item Use \code{n_masks > 1} for more stable selection.
  \item \code{warm_start = TRUE} usually reduces runtime, especially for larger alpha grids.
}

\strong{Interpretation note}
\itemize{
  \item With tight iteration budgets (\code{max_iter} small), warm starts can slightly change which alpha wins.
  \item For final model selection in sensitive comparisons, consider a second pass with larger \code{max_iter} or \code{warm_start = FALSE}.
}
}
