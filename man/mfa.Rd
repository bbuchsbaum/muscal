% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R, R/mfa.R
\name{mfa}
\alias{mfa}
\alias{mfa.list}
\alias{mfa.multiblock}
\title{Multiple Factor Analysis (generic)}
\usage{
mfa(data, preproc, ncomp = 2, normalization = "MFA", A = NULL, M = NULL, ...)

\method{mfa}{list}(
  data,
  preproc = center(),
  ncomp = 2,
  normalization = c("MFA", "RV", "None", "Frob", "custom"),
  M = NULL,
  A = NULL,
  ...
)

\method{mfa}{multiblock}(
  data,
  preproc = center(),
  ncomp = 2,
  normalization = c("MFA", "RV", "None", "Frob", "custom"),
  M = NULL,
  A = NULL,
  ...
)
}
\arguments{
\item{data}{The dataset on which the bootstrap resampling should be performed.}

\item{preproc}{A \link[multivarious]{preprocessing pipeline}.  Defaults to
`multivarious::center()` in the concrete methods.}

\item{ncomp}{Integer; the number of discriminant components to compute.}

\item{normalization}{Character string specifying the block‑weighting scheme
(see [mfa.multiblock]).}

\item{A, M}{Optional user‑supplied column/row weight matrices used when
`normalization = "custom"`.}

\item{...}{Additional arguments passed to the method.}
}
\value{
An object of class `mfa`.
}
\description{
A generic front–end for **Multiple Factor Analysis** (MFA).  Concrete methods
should perform the estimation and return an object inheriting from class
`\code{mfa}`.
}
\details{
The \code{mfa.list} method applies the MFA algorithm to a list of data matrices or data frames.
This method first converts the list to a multiblock object and then calls \code{mfa.multiblock}.

The \code{mfa.multiblock} method implements Multiple Factor Analysis for a collection of
data blocks. This method handles data preprocessing, block normalization, and integration
of multiple data tables that share the same observations.

Normalization options include:
\itemize{
\item \code{MFA}: Scales each block by its first singular value (default)
\item \code{RV}: Normalizes blocks based on RV matrix correlation
\item \code{None}: No scaling applied
\item \code{Frob}: Uses Frobenius norm for scaling
\item \code{custom}: Uses custom weight matrices provided via A and M parameters
}
}
\examples{
# Apply MFA to a list of matrices
X <- replicate(5, { matrix(rnorm(10*10), 10, 10) }, simplify=FALSE)
res <- mfa(X, ncomp=3, normalization="MFA")

# Create 5 random matrices of the same size
X <- replicate(5, { matrix(rnorm(10*10), 10, 10) }, simplify=FALSE)

# Apply MFA with MFA normalization
res <- mfa(X, ncomp=3, normalization="MFA")

# Project a block onto the model
p <- multivarious::project_block(res, X[[1]], 1)

# Verify number of components
stopifnot(ncol(multivarious::scores(res)) == 3)

# Create a classifier
labs <- letters[1:10]
cfier <- multivarious::classifier(res, new_data=do.call(cbind, X), labels=labs)
pred <- predict(cfier, X[1:2,])

# Create a classifier using a specific block
cfier2 <- multivarious::classifier(res, new_data=X[[2]], labels=labs, 
                                  colind=res$block_indices[[2]])
pred2 <- predict(cfier2, X[1:2,res$block_indices[[2]]])
}
\references{
Abdi, H., Williams, L. J., & Valentin, D. (2013). *Multiple factor analysis:
principal component analysis for multi‑table and multi‑block data sets*.
**Wiley Interdisciplinary Reviews: Computational Statistics, 5**(2), 149–179.
}
